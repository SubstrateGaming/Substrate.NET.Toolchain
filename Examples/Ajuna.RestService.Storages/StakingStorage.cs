//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Ajuna.NetApi.Model.PalletStaking;
using Ajuna.NetApi.Model.SpArithmetic;
using Ajuna.NetApi.Model.SpCore;
using Ajuna.NetApi.Model.Types.Base;
using Ajuna.NetApi.Model.Types.Primitive;
using Ajuna.ServiceLayer.Attributes;
using Ajuna.ServiceLayer.Storage;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;


namespace Ajuna.Infrastructure.Storages
{
    
    
    public interface IStakingStorage : IStorage
    {
        
        /// <summary>
        /// >> HistoryDepth
        ///  Number of eras to keep in history.
        /// 
        ///  Information is kept for eras in `[current_era - history_depth; current_era]`.
        /// 
        ///  Must be more than the number of eras delayed by session otherwise. I.e. active era must
        ///  always be in history. I.e. `active_era > current_era - history_depth` must be
        ///  guaranteed.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetHistoryDepth();
        
        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of staking participants.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetValidatorCount();
        
        /// <summary>
        /// >> MinimumValidatorCount
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetMinimumValidatorCount();
        
        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        BaseVec<Ajuna.NetApi.Model.SpCore.AccountId32> GetInvulnerables();
        
        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// </summary>
        Ajuna.NetApi.Model.SpCore.AccountId32 GetBonded(string key);
        
        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U128 GetMinNominatorBond();
        
        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U128 GetMinValidatorBond();
        
        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.StakingLedger GetLedger(string key);
        
        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination GetPayee(string key);
        
        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  When updating this storage item, you must also update the `CounterForValidators`.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs GetValidators(string key);
        
        /// <summary>
        /// >> CounterForValidators
        ///  A tracker to keep count of the number of items in the `Validators` map.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetCounterForValidators();
        
        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetMaxValidatorsCount();
        
        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to the set of stash keys of all validators to nominate.
        /// 
        ///  When updating this storage item, you must also update the `CounterForNominators`.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.Nominations GetNominators(string key);
        
        /// <summary>
        /// >> CounterForNominators
        ///  A tracker to keep count of the number of items in the `Nominators` map.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetCounterForNominators();
        
        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetMaxNominatorsCount();
        
        /// <summary>
        /// >> CurrentEra
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetCurrentEra();
        
        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.ActiveEraInfo GetActiveEra();
        
        /// <summary>
        /// >> ErasStartSessionIndex
        ///  The session index at which the era start for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetErasStartSessionIndex(string key);
        
        /// <summary>
        /// >> ErasStakers
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.Exposure GetErasStakers(string key);
        
        /// <summary>
        /// >> ErasStakersClipped
        ///  Clipped Exposure of validator at era.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxNominatorRewardedPerValidator` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.Exposure GetErasStakersClipped(string key);
        
        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs GetErasValidatorPrefs(string key);
        
        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U128 GetErasValidatorReward(string key);
        
        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last `HISTORY_DEPTH` eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.EraRewardPoints GetErasRewardPoints(string key);
        
        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last `HISTORY_DEPTH` eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U128 GetErasTotalStake(string key);
        
        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.EnumForcing GetForceEra();
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        Ajuna.NetApi.Model.SpArithmetic.Perbill GetSlashRewardFraction();
        
        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U128 GetCanceledSlashPayout();
        
        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        BaseVec<Ajuna.NetApi.Model.PalletStaking.UnappliedSlash> GetUnappliedSlashes(string key);
        
        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.U32>> GetBondedEras();
        
        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        BaseTuple<Ajuna.NetApi.Model.SpArithmetic.Perbill,Ajuna.NetApi.Model.Types.Primitive.U128> GetValidatorSlashInEra(string key);
        
        /// <summary>
        /// >> NominatorSlashInEra
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U128 GetNominatorSlashInEra(string key);
        
        /// <summary>
        /// >> SlashingSpans
        ///  Slashing spans for stash accounts.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.SlashingSpans GetSlashingSpans(string key);
        
        /// <summary>
        /// >> SpanSlash
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.SpanRecord GetSpanSlash(string key);
        
        /// <summary>
        /// >> EarliestUnappliedSlash
        ///  The earliest era for which we have a pending, unapplied slash.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetEarliestUnappliedSlash();
        
        /// <summary>
        /// >> CurrentPlannedSession
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetCurrentPlannedSession();
        
        /// <summary>
        /// >> StorageVersion
        ///  True if network has been upgraded to this version.
        ///  Storage version of the pallet.
        /// 
        ///  This is set to v7.0.0 for new networks.
        /// </summary>
        Ajuna.NetApi.Model.PalletStaking.EnumReleases GetStorageVersion();
        
        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        Ajuna.NetApi.Model.SpArithmetic.Percent GetChillThreshold();
    }
    
    public sealed class StakingStorage : IStakingStorage
    {
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _historyDepthTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _validatorCountTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _minimumValidatorCountTypedStorage;
        
        private TypedStorage<BaseVec<Ajuna.NetApi.Model.SpCore.AccountId32>> _invulnerablesTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.SpCore.AccountId32> _bondedTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U128> _minNominatorBondTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U128> _minValidatorBondTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.StakingLedger> _ledgerTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination> _payeeTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs> _validatorsTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _counterForValidatorsTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _maxValidatorsCountTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.Nominations> _nominatorsTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _counterForNominatorsTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _maxNominatorsCountTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _currentEraTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.PalletStaking.ActiveEraInfo> _activeEraTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _erasStartSessionIndexTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.Exposure> _erasStakersTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.Exposure> _erasStakersClippedTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs> _erasValidatorPrefsTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U128> _erasValidatorRewardTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.EraRewardPoints> _erasRewardPointsTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U128> _erasTotalStakeTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.PalletStaking.EnumForcing> _forceEraTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.SpArithmetic.Perbill> _slashRewardFractionTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U128> _canceledSlashPayoutTypedStorage;
        
        private TypedMapStorage<BaseVec<Ajuna.NetApi.Model.PalletStaking.UnappliedSlash>> _unappliedSlashesTypedStorage;
        
        private TypedStorage<BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.U32>>> _bondedErasTypedStorage;
        
        private TypedMapStorage<BaseTuple<Ajuna.NetApi.Model.SpArithmetic.Perbill,Ajuna.NetApi.Model.Types.Primitive.U128>> _validatorSlashInEraTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U128> _nominatorSlashInEraTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.SlashingSpans> _slashingSpansTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.SpanRecord> _spanSlashTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _earliestUnappliedSlashTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _currentPlannedSessionTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.PalletStaking.EnumReleases> _storageVersionTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.SpArithmetic.Percent> _chillThresholdTypedStorage;
        
        public StakingStorage(IStorageChangeDelegate storageChangeDelegate)
        {
            this.HistoryDepthTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.HistoryDepth", storageChangeDelegate);
            this.ValidatorCountTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.ValidatorCount", storageChangeDelegate);
            this.MinimumValidatorCountTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.MinimumValidatorCount", storageChangeDelegate);
            this.InvulnerablesTypedStorage = new TypedStorage<BaseVec<Ajuna.NetApi.Model.SpCore.AccountId32>>("Staking.Invulnerables", storageChangeDelegate);
            this.BondedTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.SpCore.AccountId32>("Staking.Bonded", storageChangeDelegate);
            this.MinNominatorBondTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U128>("Staking.MinNominatorBond", storageChangeDelegate);
            this.MinValidatorBondTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U128>("Staking.MinValidatorBond", storageChangeDelegate);
            this.LedgerTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.StakingLedger>("Staking.Ledger", storageChangeDelegate);
            this.PayeeTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination>("Staking.Payee", storageChangeDelegate);
            this.ValidatorsTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs>("Staking.Validators", storageChangeDelegate);
            this.CounterForValidatorsTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.CounterForValidators", storageChangeDelegate);
            this.MaxValidatorsCountTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.MaxValidatorsCount", storageChangeDelegate);
            this.NominatorsTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.Nominations>("Staking.Nominators", storageChangeDelegate);
            this.CounterForNominatorsTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.CounterForNominators", storageChangeDelegate);
            this.MaxNominatorsCountTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.MaxNominatorsCount", storageChangeDelegate);
            this.CurrentEraTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.CurrentEra", storageChangeDelegate);
            this.ActiveEraTypedStorage = new TypedStorage<Ajuna.NetApi.Model.PalletStaking.ActiveEraInfo>("Staking.ActiveEra", storageChangeDelegate);
            this.ErasStartSessionIndexTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.ErasStartSessionIndex", storageChangeDelegate);
            this.ErasStakersTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.Exposure>("Staking.ErasStakers", storageChangeDelegate);
            this.ErasStakersClippedTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.Exposure>("Staking.ErasStakersClipped", storageChangeDelegate);
            this.ErasValidatorPrefsTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs>("Staking.ErasValidatorPrefs", storageChangeDelegate);
            this.ErasValidatorRewardTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U128>("Staking.ErasValidatorReward", storageChangeDelegate);
            this.ErasRewardPointsTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.EraRewardPoints>("Staking.ErasRewardPoints", storageChangeDelegate);
            this.ErasTotalStakeTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U128>("Staking.ErasTotalStake", storageChangeDelegate);
            this.ForceEraTypedStorage = new TypedStorage<Ajuna.NetApi.Model.PalletStaking.EnumForcing>("Staking.ForceEra", storageChangeDelegate);
            this.SlashRewardFractionTypedStorage = new TypedStorage<Ajuna.NetApi.Model.SpArithmetic.Perbill>("Staking.SlashRewardFraction", storageChangeDelegate);
            this.CanceledSlashPayoutTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U128>("Staking.CanceledSlashPayout", storageChangeDelegate);
            this.UnappliedSlashesTypedStorage = new TypedMapStorage<BaseVec<Ajuna.NetApi.Model.PalletStaking.UnappliedSlash>>("Staking.UnappliedSlashes", storageChangeDelegate);
            this.BondedErasTypedStorage = new TypedStorage<BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.U32>>>("Staking.BondedEras", storageChangeDelegate);
            this.ValidatorSlashInEraTypedStorage = new TypedMapStorage<BaseTuple<Ajuna.NetApi.Model.SpArithmetic.Perbill,Ajuna.NetApi.Model.Types.Primitive.U128>>("Staking.ValidatorSlashInEra", storageChangeDelegate);
            this.NominatorSlashInEraTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U128>("Staking.NominatorSlashInEra", storageChangeDelegate);
            this.SlashingSpansTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.SlashingSpans>("Staking.SlashingSpans", storageChangeDelegate);
            this.SpanSlashTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.SpanRecord>("Staking.SpanSlash", storageChangeDelegate);
            this.EarliestUnappliedSlashTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.EarliestUnappliedSlash", storageChangeDelegate);
            this.CurrentPlannedSessionTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("Staking.CurrentPlannedSession", storageChangeDelegate);
            this.StorageVersionTypedStorage = new TypedStorage<Ajuna.NetApi.Model.PalletStaking.EnumReleases>("Staking.StorageVersion", storageChangeDelegate);
            this.ChillThresholdTypedStorage = new TypedStorage<Ajuna.NetApi.Model.SpArithmetic.Percent>("Staking.ChillThreshold", storageChangeDelegate);
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> HistoryDepthTypedStorage
        {
            get
            {
                return _historyDepthTypedStorage;
            }
            set
            {
                _historyDepthTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> ValidatorCountTypedStorage
        {
            get
            {
                return _validatorCountTypedStorage;
            }
            set
            {
                _validatorCountTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> MinimumValidatorCountTypedStorage
        {
            get
            {
                return _minimumValidatorCountTypedStorage;
            }
            set
            {
                _minimumValidatorCountTypedStorage = value;
            }
        }
        
        public TypedStorage<BaseVec<Ajuna.NetApi.Model.SpCore.AccountId32>> InvulnerablesTypedStorage
        {
            get
            {
                return _invulnerablesTypedStorage;
            }
            set
            {
                _invulnerablesTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.SpCore.AccountId32> BondedTypedStorage
        {
            get
            {
                return _bondedTypedStorage;
            }
            set
            {
                _bondedTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U128> MinNominatorBondTypedStorage
        {
            get
            {
                return _minNominatorBondTypedStorage;
            }
            set
            {
                _minNominatorBondTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U128> MinValidatorBondTypedStorage
        {
            get
            {
                return _minValidatorBondTypedStorage;
            }
            set
            {
                _minValidatorBondTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.StakingLedger> LedgerTypedStorage
        {
            get
            {
                return _ledgerTypedStorage;
            }
            set
            {
                _ledgerTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination> PayeeTypedStorage
        {
            get
            {
                return _payeeTypedStorage;
            }
            set
            {
                _payeeTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs> ValidatorsTypedStorage
        {
            get
            {
                return _validatorsTypedStorage;
            }
            set
            {
                _validatorsTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> CounterForValidatorsTypedStorage
        {
            get
            {
                return _counterForValidatorsTypedStorage;
            }
            set
            {
                _counterForValidatorsTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> MaxValidatorsCountTypedStorage
        {
            get
            {
                return _maxValidatorsCountTypedStorage;
            }
            set
            {
                _maxValidatorsCountTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.Nominations> NominatorsTypedStorage
        {
            get
            {
                return _nominatorsTypedStorage;
            }
            set
            {
                _nominatorsTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> CounterForNominatorsTypedStorage
        {
            get
            {
                return _counterForNominatorsTypedStorage;
            }
            set
            {
                _counterForNominatorsTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> MaxNominatorsCountTypedStorage
        {
            get
            {
                return _maxNominatorsCountTypedStorage;
            }
            set
            {
                _maxNominatorsCountTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> CurrentEraTypedStorage
        {
            get
            {
                return _currentEraTypedStorage;
            }
            set
            {
                _currentEraTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.PalletStaking.ActiveEraInfo> ActiveEraTypedStorage
        {
            get
            {
                return _activeEraTypedStorage;
            }
            set
            {
                _activeEraTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U32> ErasStartSessionIndexTypedStorage
        {
            get
            {
                return _erasStartSessionIndexTypedStorage;
            }
            set
            {
                _erasStartSessionIndexTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.Exposure> ErasStakersTypedStorage
        {
            get
            {
                return _erasStakersTypedStorage;
            }
            set
            {
                _erasStakersTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.Exposure> ErasStakersClippedTypedStorage
        {
            get
            {
                return _erasStakersClippedTypedStorage;
            }
            set
            {
                _erasStakersClippedTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs> ErasValidatorPrefsTypedStorage
        {
            get
            {
                return _erasValidatorPrefsTypedStorage;
            }
            set
            {
                _erasValidatorPrefsTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U128> ErasValidatorRewardTypedStorage
        {
            get
            {
                return _erasValidatorRewardTypedStorage;
            }
            set
            {
                _erasValidatorRewardTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.EraRewardPoints> ErasRewardPointsTypedStorage
        {
            get
            {
                return _erasRewardPointsTypedStorage;
            }
            set
            {
                _erasRewardPointsTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U128> ErasTotalStakeTypedStorage
        {
            get
            {
                return _erasTotalStakeTypedStorage;
            }
            set
            {
                _erasTotalStakeTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.PalletStaking.EnumForcing> ForceEraTypedStorage
        {
            get
            {
                return _forceEraTypedStorage;
            }
            set
            {
                _forceEraTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.SpArithmetic.Perbill> SlashRewardFractionTypedStorage
        {
            get
            {
                return _slashRewardFractionTypedStorage;
            }
            set
            {
                _slashRewardFractionTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U128> CanceledSlashPayoutTypedStorage
        {
            get
            {
                return _canceledSlashPayoutTypedStorage;
            }
            set
            {
                _canceledSlashPayoutTypedStorage = value;
            }
        }
        
        public TypedMapStorage<BaseVec<Ajuna.NetApi.Model.PalletStaking.UnappliedSlash>> UnappliedSlashesTypedStorage
        {
            get
            {
                return _unappliedSlashesTypedStorage;
            }
            set
            {
                _unappliedSlashesTypedStorage = value;
            }
        }
        
        public TypedStorage<BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.U32>>> BondedErasTypedStorage
        {
            get
            {
                return _bondedErasTypedStorage;
            }
            set
            {
                _bondedErasTypedStorage = value;
            }
        }
        
        public TypedMapStorage<BaseTuple<Ajuna.NetApi.Model.SpArithmetic.Perbill,Ajuna.NetApi.Model.Types.Primitive.U128>> ValidatorSlashInEraTypedStorage
        {
            get
            {
                return _validatorSlashInEraTypedStorage;
            }
            set
            {
                _validatorSlashInEraTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.Types.Primitive.U128> NominatorSlashInEraTypedStorage
        {
            get
            {
                return _nominatorSlashInEraTypedStorage;
            }
            set
            {
                _nominatorSlashInEraTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.SlashingSpans> SlashingSpansTypedStorage
        {
            get
            {
                return _slashingSpansTypedStorage;
            }
            set
            {
                _slashingSpansTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletStaking.SpanRecord> SpanSlashTypedStorage
        {
            get
            {
                return _spanSlashTypedStorage;
            }
            set
            {
                _spanSlashTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> EarliestUnappliedSlashTypedStorage
        {
            get
            {
                return _earliestUnappliedSlashTypedStorage;
            }
            set
            {
                _earliestUnappliedSlashTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> CurrentPlannedSessionTypedStorage
        {
            get
            {
                return _currentPlannedSessionTypedStorage;
            }
            set
            {
                _currentPlannedSessionTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.PalletStaking.EnumReleases> StorageVersionTypedStorage
        {
            get
            {
                return _storageVersionTypedStorage;
            }
            set
            {
                _storageVersionTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.SpArithmetic.Percent> ChillThresholdTypedStorage
        {
            get
            {
                return _chillThresholdTypedStorage;
            }
            set
            {
                _chillThresholdTypedStorage = value;
            }
        }
        
        public async Task InitializeAsync(Ajuna.NetApi.SubstrateClient client)
        {
            await HistoryDepthTypedStorage.InitializeAsync(client, "Staking", "HistoryDepth");
            await ValidatorCountTypedStorage.InitializeAsync(client, "Staking", "ValidatorCount");
            await MinimumValidatorCountTypedStorage.InitializeAsync(client, "Staking", "MinimumValidatorCount");
            await InvulnerablesTypedStorage.InitializeAsync(client, "Staking", "Invulnerables");
            await BondedTypedStorage.InitializeAsync(client, "Staking", "Bonded");
            await MinNominatorBondTypedStorage.InitializeAsync(client, "Staking", "MinNominatorBond");
            await MinValidatorBondTypedStorage.InitializeAsync(client, "Staking", "MinValidatorBond");
            await LedgerTypedStorage.InitializeAsync(client, "Staking", "Ledger");
            await PayeeTypedStorage.InitializeAsync(client, "Staking", "Payee");
            await ValidatorsTypedStorage.InitializeAsync(client, "Staking", "Validators");
            await CounterForValidatorsTypedStorage.InitializeAsync(client, "Staking", "CounterForValidators");
            await MaxValidatorsCountTypedStorage.InitializeAsync(client, "Staking", "MaxValidatorsCount");
            await NominatorsTypedStorage.InitializeAsync(client, "Staking", "Nominators");
            await CounterForNominatorsTypedStorage.InitializeAsync(client, "Staking", "CounterForNominators");
            await MaxNominatorsCountTypedStorage.InitializeAsync(client, "Staking", "MaxNominatorsCount");
            await CurrentEraTypedStorage.InitializeAsync(client, "Staking", "CurrentEra");
            await ActiveEraTypedStorage.InitializeAsync(client, "Staking", "ActiveEra");
            await ErasStartSessionIndexTypedStorage.InitializeAsync(client, "Staking", "ErasStartSessionIndex");
            await ErasStakersTypedStorage.InitializeAsync(client, "Staking", "ErasStakers");
            await ErasStakersClippedTypedStorage.InitializeAsync(client, "Staking", "ErasStakersClipped");
            await ErasValidatorPrefsTypedStorage.InitializeAsync(client, "Staking", "ErasValidatorPrefs");
            await ErasValidatorRewardTypedStorage.InitializeAsync(client, "Staking", "ErasValidatorReward");
            await ErasRewardPointsTypedStorage.InitializeAsync(client, "Staking", "ErasRewardPoints");
            await ErasTotalStakeTypedStorage.InitializeAsync(client, "Staking", "ErasTotalStake");
            await ForceEraTypedStorage.InitializeAsync(client, "Staking", "ForceEra");
            await SlashRewardFractionTypedStorage.InitializeAsync(client, "Staking", "SlashRewardFraction");
            await CanceledSlashPayoutTypedStorage.InitializeAsync(client, "Staking", "CanceledSlashPayout");
            await UnappliedSlashesTypedStorage.InitializeAsync(client, "Staking", "UnappliedSlashes");
            await BondedErasTypedStorage.InitializeAsync(client, "Staking", "BondedEras");
            await ValidatorSlashInEraTypedStorage.InitializeAsync(client, "Staking", "ValidatorSlashInEra");
            await NominatorSlashInEraTypedStorage.InitializeAsync(client, "Staking", "NominatorSlashInEra");
            await SlashingSpansTypedStorage.InitializeAsync(client, "Staking", "SlashingSpans");
            await SpanSlashTypedStorage.InitializeAsync(client, "Staking", "SpanSlash");
            await EarliestUnappliedSlashTypedStorage.InitializeAsync(client, "Staking", "EarliestUnappliedSlash");
            await CurrentPlannedSessionTypedStorage.InitializeAsync(client, "Staking", "CurrentPlannedSession");
            await StorageVersionTypedStorage.InitializeAsync(client, "Staking", "StorageVersion");
            await ChillThresholdTypedStorage.InitializeAsync(client, "Staking", "ChillThreshold");
        }
        
        [StorageChange("Staking", "HistoryDepth")]
        public void OnUpdateHistoryDepth(string data)
        {
            HistoryDepthTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> HistoryDepth
        ///  Number of eras to keep in history.
        /// 
        ///  Information is kept for eras in `[current_era - history_depth; current_era]`.
        /// 
        ///  Must be more than the number of eras delayed by session otherwise. I.e. active era must
        ///  always be in history. I.e. `active_era > current_era - history_depth` must be
        ///  guaranteed.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetHistoryDepth()
        {
            return HistoryDepthTypedStorage.Get();
        }
        
        [StorageChange("Staking", "ValidatorCount")]
        public void OnUpdateValidatorCount(string data)
        {
            ValidatorCountTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of staking participants.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetValidatorCount()
        {
            return ValidatorCountTypedStorage.Get();
        }
        
        [StorageChange("Staking", "MinimumValidatorCount")]
        public void OnUpdateMinimumValidatorCount(string data)
        {
            MinimumValidatorCountTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MinimumValidatorCount
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetMinimumValidatorCount()
        {
            return MinimumValidatorCountTypedStorage.Get();
        }
        
        [StorageChange("Staking", "Invulnerables")]
        public void OnUpdateInvulnerables(string data)
        {
            InvulnerablesTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public BaseVec<Ajuna.NetApi.Model.SpCore.AccountId32> GetInvulnerables()
        {
            return InvulnerablesTypedStorage.Get();
        }
        
        [StorageChange("Staking", "Bonded")]
        public void OnUpdateBonded(string key, string data)
        {
            BondedTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// </summary>
        public Ajuna.NetApi.Model.SpCore.AccountId32 GetBonded(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (BondedTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.SpCore.AccountId32 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "MinNominatorBond")]
        public void OnUpdateMinNominatorBond(string data)
        {
            MinNominatorBondTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U128 GetMinNominatorBond()
        {
            return MinNominatorBondTypedStorage.Get();
        }
        
        [StorageChange("Staking", "MinValidatorBond")]
        public void OnUpdateMinValidatorBond(string data)
        {
            MinValidatorBondTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U128 GetMinValidatorBond()
        {
            return MinValidatorBondTypedStorage.Get();
        }
        
        [StorageChange("Staking", "Ledger")]
        public void OnUpdateLedger(string key, string data)
        {
            LedgerTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.StakingLedger GetLedger(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (LedgerTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.StakingLedger result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "Payee")]
        public void OnUpdatePayee(string key, string data)
        {
            PayeeTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination GetPayee(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (PayeeTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "Validators")]
        public void OnUpdateValidators(string key, string data)
        {
            ValidatorsTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  When updating this storage item, you must also update the `CounterForValidators`.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs GetValidators(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ValidatorsTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "CounterForValidators")]
        public void OnUpdateCounterForValidators(string data)
        {
            CounterForValidatorsTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CounterForValidators
        ///  A tracker to keep count of the number of items in the `Validators` map.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetCounterForValidators()
        {
            return CounterForValidatorsTypedStorage.Get();
        }
        
        [StorageChange("Staking", "MaxValidatorsCount")]
        public void OnUpdateMaxValidatorsCount(string data)
        {
            MaxValidatorsCountTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetMaxValidatorsCount()
        {
            return MaxValidatorsCountTypedStorage.Get();
        }
        
        [StorageChange("Staking", "Nominators")]
        public void OnUpdateNominators(string key, string data)
        {
            NominatorsTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to the set of stash keys of all validators to nominate.
        /// 
        ///  When updating this storage item, you must also update the `CounterForNominators`.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.Nominations GetNominators(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (NominatorsTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.Nominations result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "CounterForNominators")]
        public void OnUpdateCounterForNominators(string data)
        {
            CounterForNominatorsTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CounterForNominators
        ///  A tracker to keep count of the number of items in the `Nominators` map.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetCounterForNominators()
        {
            return CounterForNominatorsTypedStorage.Get();
        }
        
        [StorageChange("Staking", "MaxNominatorsCount")]
        public void OnUpdateMaxNominatorsCount(string data)
        {
            MaxNominatorsCountTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetMaxNominatorsCount()
        {
            return MaxNominatorsCountTypedStorage.Get();
        }
        
        [StorageChange("Staking", "CurrentEra")]
        public void OnUpdateCurrentEra(string data)
        {
            CurrentEraTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CurrentEra
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetCurrentEra()
        {
            return CurrentEraTypedStorage.Get();
        }
        
        [StorageChange("Staking", "ActiveEra")]
        public void OnUpdateActiveEra(string data)
        {
            ActiveEraTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.ActiveEraInfo GetActiveEra()
        {
            return ActiveEraTypedStorage.Get();
        }
        
        [StorageChange("Staking", "ErasStartSessionIndex")]
        public void OnUpdateErasStartSessionIndex(string key, string data)
        {
            ErasStartSessionIndexTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasStartSessionIndex
        ///  The session index at which the era start for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetErasStartSessionIndex(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasStartSessionIndexTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.Types.Primitive.U32 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "ErasStakers")]
        public void OnUpdateErasStakers(string key, string data)
        {
            ErasStakersTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasStakers
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.Exposure GetErasStakers(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasStakersTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.Exposure result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "ErasStakersClipped")]
        public void OnUpdateErasStakersClipped(string key, string data)
        {
            ErasStakersClippedTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasStakersClipped
        ///  Clipped Exposure of validator at era.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxNominatorRewardedPerValidator` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.Exposure GetErasStakersClipped(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasStakersClippedTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.Exposure result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "ErasValidatorPrefs")]
        public void OnUpdateErasValidatorPrefs(string key, string data)
        {
            ErasValidatorPrefsTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs GetErasValidatorPrefs(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasValidatorPrefsTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "ErasValidatorReward")]
        public void OnUpdateErasValidatorReward(string key, string data)
        {
            ErasValidatorRewardTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U128 GetErasValidatorReward(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasValidatorRewardTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.Types.Primitive.U128 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "ErasRewardPoints")]
        public void OnUpdateErasRewardPoints(string key, string data)
        {
            ErasRewardPointsTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last `HISTORY_DEPTH` eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.EraRewardPoints GetErasRewardPoints(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasRewardPointsTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.EraRewardPoints result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "ErasTotalStake")]
        public void OnUpdateErasTotalStake(string key, string data)
        {
            ErasTotalStakeTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last `HISTORY_DEPTH` eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U128 GetErasTotalStake(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasTotalStakeTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.Types.Primitive.U128 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "ForceEra")]
        public void OnUpdateForceEra(string data)
        {
            ForceEraTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.EnumForcing GetForceEra()
        {
            return ForceEraTypedStorage.Get();
        }
        
        [StorageChange("Staking", "SlashRewardFraction")]
        public void OnUpdateSlashRewardFraction(string data)
        {
            SlashRewardFractionTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public Ajuna.NetApi.Model.SpArithmetic.Perbill GetSlashRewardFraction()
        {
            return SlashRewardFractionTypedStorage.Get();
        }
        
        [StorageChange("Staking", "CanceledSlashPayout")]
        public void OnUpdateCanceledSlashPayout(string data)
        {
            CanceledSlashPayoutTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U128 GetCanceledSlashPayout()
        {
            return CanceledSlashPayoutTypedStorage.Get();
        }
        
        [StorageChange("Staking", "UnappliedSlashes")]
        public void OnUpdateUnappliedSlashes(string key, string data)
        {
            UnappliedSlashesTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public BaseVec<Ajuna.NetApi.Model.PalletStaking.UnappliedSlash> GetUnappliedSlashes(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (UnappliedSlashesTypedStorage.Dictionary.TryGetValue(key, out BaseVec<Ajuna.NetApi.Model.PalletStaking.UnappliedSlash> result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "BondedEras")]
        public void OnUpdateBondedEras(string data)
        {
            BondedErasTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.U32>> GetBondedEras()
        {
            return BondedErasTypedStorage.Get();
        }
        
        [StorageChange("Staking", "ValidatorSlashInEra")]
        public void OnUpdateValidatorSlashInEra(string key, string data)
        {
            ValidatorSlashInEraTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public BaseTuple<Ajuna.NetApi.Model.SpArithmetic.Perbill,Ajuna.NetApi.Model.Types.Primitive.U128> GetValidatorSlashInEra(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ValidatorSlashInEraTypedStorage.Dictionary.TryGetValue(key, out BaseTuple<Ajuna.NetApi.Model.SpArithmetic.Perbill,Ajuna.NetApi.Model.Types.Primitive.U128> result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "NominatorSlashInEra")]
        public void OnUpdateNominatorSlashInEra(string key, string data)
        {
            NominatorSlashInEraTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> NominatorSlashInEra
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U128 GetNominatorSlashInEra(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (NominatorSlashInEraTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.Types.Primitive.U128 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "SlashingSpans")]
        public void OnUpdateSlashingSpans(string key, string data)
        {
            SlashingSpansTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> SlashingSpans
        ///  Slashing spans for stash accounts.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.SlashingSpans GetSlashingSpans(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (SlashingSpansTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.SlashingSpans result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "SpanSlash")]
        public void OnUpdateSpanSlash(string key, string data)
        {
            SpanSlashTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> SpanSlash
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.SpanRecord GetSpanSlash(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (SpanSlashTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletStaking.SpanRecord result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("Staking", "EarliestUnappliedSlash")]
        public void OnUpdateEarliestUnappliedSlash(string data)
        {
            EarliestUnappliedSlashTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> EarliestUnappliedSlash
        ///  The earliest era for which we have a pending, unapplied slash.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetEarliestUnappliedSlash()
        {
            return EarliestUnappliedSlashTypedStorage.Get();
        }
        
        [StorageChange("Staking", "CurrentPlannedSession")]
        public void OnUpdateCurrentPlannedSession(string data)
        {
            CurrentPlannedSessionTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CurrentPlannedSession
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetCurrentPlannedSession()
        {
            return CurrentPlannedSessionTypedStorage.Get();
        }
        
        [StorageChange("Staking", "StorageVersion")]
        public void OnUpdateStorageVersion(string data)
        {
            StorageVersionTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> StorageVersion
        ///  True if network has been upgraded to this version.
        ///  Storage version of the pallet.
        /// 
        ///  This is set to v7.0.0 for new networks.
        /// </summary>
        public Ajuna.NetApi.Model.PalletStaking.EnumReleases GetStorageVersion()
        {
            return StorageVersionTypedStorage.Get();
        }
        
        [StorageChange("Staking", "ChillThreshold")]
        public void OnUpdateChillThreshold(string data)
        {
            ChillThresholdTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public Ajuna.NetApi.Model.SpArithmetic.Percent GetChillThreshold()
        {
            return ChillThresholdTypedStorage.Get();
        }
    }
}

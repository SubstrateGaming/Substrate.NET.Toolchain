//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Ajuna.NetApi.Model.Base;
using Ajuna.NetApi.Model.FrameSupport;
using Ajuna.NetApi.Model.PalletElectionProviderMultiPhase;
using Ajuna.NetApi.Model.Types.Base;
using Ajuna.NetApi.Model.Types.Primitive;
using Ajuna.ServiceLayer.Attributes;
using Ajuna.ServiceLayer.Storage;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;


namespace Ajuna.Infrastructure.Storages
{
    
    
    public interface IElectionProviderMultiPhaseStorage : IStorage
    {
        
        /// <summary>
        /// >> Round
        ///  Internal counter for the number of rounds.
        /// 
        ///  This is useful for de-duplication of transactions submitted to the pool, and general
        ///  diagnostics of the pallet.
        /// 
        ///  This is merely incremented once per every time that an upstream `elect` is called.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetRound();
        
        /// <summary>
        /// >> CurrentPhase
        ///  Current phase.
        /// </summary>
        Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.EnumPhase GetCurrentPhase();
        
        /// <summary>
        /// >> QueuedSolution
        ///  Current best solution, signed or unsigned, queued to be returned upon `elect`.
        /// </summary>
        Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.ReadySolution GetQueuedSolution();
        
        /// <summary>
        /// >> Snapshot
        ///  Snapshot data of the round.
        /// 
        ///  This is created at the beginning of the signed phase and cleared upon calling `elect`.
        /// </summary>
        Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.RoundSnapshot GetSnapshot();
        
        /// <summary>
        /// >> DesiredTargets
        ///  Desired number of targets to elect for this round.
        /// 
        ///  Only exists when [`Snapshot`] is present.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetDesiredTargets();
        
        /// <summary>
        /// >> SnapshotMetadata
        ///  The metadata of the [`RoundSnapshot`]
        /// 
        ///  Only exists when [`Snapshot`] is present.
        /// </summary>
        Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SolutionOrSnapshotSize GetSnapshotMetadata();
        
        /// <summary>
        /// >> SignedSubmissionNextIndex
        ///  The next index to be assigned to an incoming signed submission.
        /// 
        ///  Every accepted submission is assigned a unique index; that index is bound to that particular
        ///  submission for the duration of the election. On election finalization, the next index is
        ///  reset to 0.
        /// 
        ///  We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its
        ///  capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,
        ///  because iteration is slow. Instead, we store the value here.
        /// </summary>
        Ajuna.NetApi.Model.Types.Primitive.U32 GetSignedSubmissionNextIndex();
        
        /// <summary>
        /// >> SignedSubmissionIndices
        ///  A sorted, bounded set of `(score, index)`, where each `index` points to a value in
        ///  `SignedSubmissions`.
        /// 
        ///  We never need to process more than a single signed submission at a time. Signed submissions
        ///  can be quite large, so we're willing to pay the cost of multiple database accesses to access
        ///  them one at a time instead of reading and decoding all of them at once.
        /// </summary>
        Ajuna.NetApi.Model.FrameSupport.BoundedBTreeMap GetSignedSubmissionIndices();
        
        /// <summary>
        /// >> SignedSubmissionsMap
        ///  Unchecked, signed solutions.
        /// 
        ///  Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
        ///  allowing us to keep only a single one in memory at a time.
        /// 
        ///  Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
        ///  affect; we shouldn't need a cryptographically secure hasher.
        /// </summary>
        Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SignedSubmission GetSignedSubmissionsMap(string key);
        
        /// <summary>
        /// >> MinimumUntrustedScore
        ///  The minimum score that each 'untrusted' solution must attain in order to be considered
        ///  feasible.
        /// 
        ///  Can be set via `set_minimum_untrusted_score`.
        /// </summary>
        Ajuna.NetApi.Model.Base.Arr3U128 GetMinimumUntrustedScore();
    }
    
    public sealed class ElectionProviderMultiPhaseStorage : IElectionProviderMultiPhaseStorage
    {
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _roundTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.EnumPhase> _currentPhaseTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.ReadySolution> _queuedSolutionTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.RoundSnapshot> _snapshotTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _desiredTargetsTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SolutionOrSnapshotSize> _snapshotMetadataTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> _signedSubmissionNextIndexTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.FrameSupport.BoundedBTreeMap> _signedSubmissionIndicesTypedStorage;
        
        private TypedMapStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SignedSubmission> _signedSubmissionsMapTypedStorage;
        
        private TypedStorage<Ajuna.NetApi.Model.Base.Arr3U128> _minimumUntrustedScoreTypedStorage;
        
        public ElectionProviderMultiPhaseStorage(IStorageChangeDelegate storageChangeDelegate)
        {
            this.RoundTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("ElectionProviderMultiPhase.Round", storageChangeDelegate);
            this.CurrentPhaseTypedStorage = new TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.EnumPhase>("ElectionProviderMultiPhase.CurrentPhase", storageChangeDelegate);
            this.QueuedSolutionTypedStorage = new TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.ReadySolution>("ElectionProviderMultiPhase.QueuedSolution", storageChangeDelegate);
            this.SnapshotTypedStorage = new TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.RoundSnapshot>("ElectionProviderMultiPhase.Snapshot", storageChangeDelegate);
            this.DesiredTargetsTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("ElectionProviderMultiPhase.DesiredTargets", storageChangeDelegate);
            this.SnapshotMetadataTypedStorage = new TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SolutionOrSnapshotSize>("ElectionProviderMultiPhase.SnapshotMetadata", storageChangeDelegate);
            this.SignedSubmissionNextIndexTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32>("ElectionProviderMultiPhase.SignedSubmissionNextIndex", storageChangeDelegate);
            this.SignedSubmissionIndicesTypedStorage = new TypedStorage<Ajuna.NetApi.Model.FrameSupport.BoundedBTreeMap>("ElectionProviderMultiPhase.SignedSubmissionIndices", storageChangeDelegate);
            this.SignedSubmissionsMapTypedStorage = new TypedMapStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SignedSubmission>("ElectionProviderMultiPhase.SignedSubmissionsMap", storageChangeDelegate);
            this.MinimumUntrustedScoreTypedStorage = new TypedStorage<Ajuna.NetApi.Model.Base.Arr3U128>("ElectionProviderMultiPhase.MinimumUntrustedScore", storageChangeDelegate);
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> RoundTypedStorage
        {
            get
            {
                return _roundTypedStorage;
            }
            set
            {
                _roundTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.EnumPhase> CurrentPhaseTypedStorage
        {
            get
            {
                return _currentPhaseTypedStorage;
            }
            set
            {
                _currentPhaseTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.ReadySolution> QueuedSolutionTypedStorage
        {
            get
            {
                return _queuedSolutionTypedStorage;
            }
            set
            {
                _queuedSolutionTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.RoundSnapshot> SnapshotTypedStorage
        {
            get
            {
                return _snapshotTypedStorage;
            }
            set
            {
                _snapshotTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> DesiredTargetsTypedStorage
        {
            get
            {
                return _desiredTargetsTypedStorage;
            }
            set
            {
                _desiredTargetsTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SolutionOrSnapshotSize> SnapshotMetadataTypedStorage
        {
            get
            {
                return _snapshotMetadataTypedStorage;
            }
            set
            {
                _snapshotMetadataTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Types.Primitive.U32> SignedSubmissionNextIndexTypedStorage
        {
            get
            {
                return _signedSubmissionNextIndexTypedStorage;
            }
            set
            {
                _signedSubmissionNextIndexTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.FrameSupport.BoundedBTreeMap> SignedSubmissionIndicesTypedStorage
        {
            get
            {
                return _signedSubmissionIndicesTypedStorage;
            }
            set
            {
                _signedSubmissionIndicesTypedStorage = value;
            }
        }
        
        public TypedMapStorage<Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SignedSubmission> SignedSubmissionsMapTypedStorage
        {
            get
            {
                return _signedSubmissionsMapTypedStorage;
            }
            set
            {
                _signedSubmissionsMapTypedStorage = value;
            }
        }
        
        public TypedStorage<Ajuna.NetApi.Model.Base.Arr3U128> MinimumUntrustedScoreTypedStorage
        {
            get
            {
                return _minimumUntrustedScoreTypedStorage;
            }
            set
            {
                _minimumUntrustedScoreTypedStorage = value;
            }
        }
        
        public async Task InitializeAsync(Ajuna.NetApi.SubstrateClient client)
        {
            await RoundTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "Round");
            await CurrentPhaseTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "CurrentPhase");
            await QueuedSolutionTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "QueuedSolution");
            await SnapshotTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "Snapshot");
            await DesiredTargetsTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "DesiredTargets");
            await SnapshotMetadataTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "SnapshotMetadata");
            await SignedSubmissionNextIndexTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "SignedSubmissionNextIndex");
            await SignedSubmissionIndicesTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "SignedSubmissionIndices");
            await SignedSubmissionsMapTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "SignedSubmissionsMap");
            await MinimumUntrustedScoreTypedStorage.InitializeAsync(client, "ElectionProviderMultiPhase", "MinimumUntrustedScore");
        }
        
        [StorageChange("ElectionProviderMultiPhase", "Round")]
        public void OnUpdateRound(string data)
        {
            RoundTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> Round
        ///  Internal counter for the number of rounds.
        /// 
        ///  This is useful for de-duplication of transactions submitted to the pool, and general
        ///  diagnostics of the pallet.
        /// 
        ///  This is merely incremented once per every time that an upstream `elect` is called.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetRound()
        {
            return RoundTypedStorage.Get();
        }
        
        [StorageChange("ElectionProviderMultiPhase", "CurrentPhase")]
        public void OnUpdateCurrentPhase(string data)
        {
            CurrentPhaseTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CurrentPhase
        ///  Current phase.
        /// </summary>
        public Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.EnumPhase GetCurrentPhase()
        {
            return CurrentPhaseTypedStorage.Get();
        }
        
        [StorageChange("ElectionProviderMultiPhase", "QueuedSolution")]
        public void OnUpdateQueuedSolution(string data)
        {
            QueuedSolutionTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> QueuedSolution
        ///  Current best solution, signed or unsigned, queued to be returned upon `elect`.
        /// </summary>
        public Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.ReadySolution GetQueuedSolution()
        {
            return QueuedSolutionTypedStorage.Get();
        }
        
        [StorageChange("ElectionProviderMultiPhase", "Snapshot")]
        public void OnUpdateSnapshot(string data)
        {
            SnapshotTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> Snapshot
        ///  Snapshot data of the round.
        /// 
        ///  This is created at the beginning of the signed phase and cleared upon calling `elect`.
        /// </summary>
        public Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.RoundSnapshot GetSnapshot()
        {
            return SnapshotTypedStorage.Get();
        }
        
        [StorageChange("ElectionProviderMultiPhase", "DesiredTargets")]
        public void OnUpdateDesiredTargets(string data)
        {
            DesiredTargetsTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> DesiredTargets
        ///  Desired number of targets to elect for this round.
        /// 
        ///  Only exists when [`Snapshot`] is present.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetDesiredTargets()
        {
            return DesiredTargetsTypedStorage.Get();
        }
        
        [StorageChange("ElectionProviderMultiPhase", "SnapshotMetadata")]
        public void OnUpdateSnapshotMetadata(string data)
        {
            SnapshotMetadataTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> SnapshotMetadata
        ///  The metadata of the [`RoundSnapshot`]
        /// 
        ///  Only exists when [`Snapshot`] is present.
        /// </summary>
        public Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SolutionOrSnapshotSize GetSnapshotMetadata()
        {
            return SnapshotMetadataTypedStorage.Get();
        }
        
        [StorageChange("ElectionProviderMultiPhase", "SignedSubmissionNextIndex")]
        public void OnUpdateSignedSubmissionNextIndex(string data)
        {
            SignedSubmissionNextIndexTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> SignedSubmissionNextIndex
        ///  The next index to be assigned to an incoming signed submission.
        /// 
        ///  Every accepted submission is assigned a unique index; that index is bound to that particular
        ///  submission for the duration of the election. On election finalization, the next index is
        ///  reset to 0.
        /// 
        ///  We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its
        ///  capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,
        ///  because iteration is slow. Instead, we store the value here.
        /// </summary>
        public Ajuna.NetApi.Model.Types.Primitive.U32 GetSignedSubmissionNextIndex()
        {
            return SignedSubmissionNextIndexTypedStorage.Get();
        }
        
        [StorageChange("ElectionProviderMultiPhase", "SignedSubmissionIndices")]
        public void OnUpdateSignedSubmissionIndices(string data)
        {
            SignedSubmissionIndicesTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> SignedSubmissionIndices
        ///  A sorted, bounded set of `(score, index)`, where each `index` points to a value in
        ///  `SignedSubmissions`.
        /// 
        ///  We never need to process more than a single signed submission at a time. Signed submissions
        ///  can be quite large, so we're willing to pay the cost of multiple database accesses to access
        ///  them one at a time instead of reading and decoding all of them at once.
        /// </summary>
        public Ajuna.NetApi.Model.FrameSupport.BoundedBTreeMap GetSignedSubmissionIndices()
        {
            return SignedSubmissionIndicesTypedStorage.Get();
        }
        
        [StorageChange("ElectionProviderMultiPhase", "SignedSubmissionsMap")]
        public void OnUpdateSignedSubmissionsMap(string key, string data)
        {
            SignedSubmissionsMapTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> SignedSubmissionsMap
        ///  Unchecked, signed solutions.
        /// 
        ///  Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
        ///  allowing us to keep only a single one in memory at a time.
        /// 
        ///  Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
        ///  affect; we shouldn't need a cryptographically secure hasher.
        /// </summary>
        public Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SignedSubmission GetSignedSubmissionsMap(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (SignedSubmissionsMapTypedStorage.Dictionary.TryGetValue(key, out Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SignedSubmission result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        [StorageChange("ElectionProviderMultiPhase", "MinimumUntrustedScore")]
        public void OnUpdateMinimumUntrustedScore(string data)
        {
            MinimumUntrustedScoreTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MinimumUntrustedScore
        ///  The minimum score that each 'untrusted' solution must attain in order to be considered
        ///  feasible.
        /// 
        ///  Can be set via `set_minimum_untrusted_score`.
        /// </summary>
        public Ajuna.NetApi.Model.Base.Arr3U128 GetMinimumUntrustedScore()
        {
            return MinimumUntrustedScoreTypedStorage.Get();
        }
    }
}

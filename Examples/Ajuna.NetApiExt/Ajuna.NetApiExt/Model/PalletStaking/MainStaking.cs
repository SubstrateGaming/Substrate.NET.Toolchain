//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Ajuna.NetApi.Model.Extrinsics;
using Ajuna.NetApi.Model.Meta;
using Ajuna.NetApi.Model.PalletStaking;
using Ajuna.NetApi.Model.SpArithmetic;
using Ajuna.NetApi.Model.SpCore;
using Ajuna.NetApi.Model.SpRuntime;
using Ajuna.NetApi.Model.Types;
using Ajuna.NetApi.Model.Types.Base;
using Ajuna.NetApi.Model.Types.Primitive;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Ajuna.NetApi.Model.PalletStaking
{
    
    
    public sealed class StakingStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        public StakingStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "HistoryDepth"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ValidatorCount"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinimumValidatorCount"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Invulnerables"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(BaseVec<Ajuna.NetApi.Model.SpCore.AccountId32>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Bonded"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.SpCore.AccountId32), typeof(Ajuna.NetApi.Model.SpCore.AccountId32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinNominatorBond"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinValidatorBond"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Ledger"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Ajuna.NetApi.Model.SpCore.AccountId32), typeof(Ajuna.NetApi.Model.PalletStaking.StakingLedger)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Payee"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.SpCore.AccountId32), typeof(Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Validators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.SpCore.AccountId32), typeof(Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForValidators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxValidatorsCount"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Nominators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.SpCore.AccountId32), typeof(Ajuna.NetApi.Model.PalletStaking.Nominations)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForNominators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxNominatorsCount"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CurrentEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ActiveEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.PalletStaking.ActiveEraInfo)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStartSessionIndex"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakers"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32>), typeof(Ajuna.NetApi.Model.PalletStaking.Exposure)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakersClipped"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32>), typeof(Ajuna.NetApi.Model.PalletStaking.Exposure)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasValidatorPrefs"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32>), typeof(Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasValidatorReward"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasRewardPoints"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(Ajuna.NetApi.Model.PalletStaking.EraRewardPoints)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasTotalStake"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ForceEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.PalletStaking.EnumForcing)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SlashRewardFraction"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.SpArithmetic.Perbill)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CanceledSlashPayout"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "UnappliedSlashes"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.Types.Primitive.U32), typeof(BaseVec<Ajuna.NetApi.Model.PalletStaking.UnappliedSlash>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "BondedEras"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.U32>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ValidatorSlashInEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32>), typeof(BaseTuple<Ajuna.NetApi.Model.SpArithmetic.Perbill,Ajuna.NetApi.Model.Types.Primitive.U128>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "NominatorSlashInEra"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32>), typeof(Ajuna.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SlashingSpans"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Ajuna.NetApi.Model.SpCore.AccountId32), typeof(Ajuna.NetApi.Model.PalletStaking.SlashingSpans)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SpanSlash"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                            Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32,Ajuna.NetApi.Model.Types.Primitive.U32>), typeof(Ajuna.NetApi.Model.PalletStaking.SpanRecord)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "EarliestUnappliedSlash"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CurrentPlannedSession"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "OffendingValidators"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.Bool>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "StorageVersion"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.PalletStaking.EnumReleases)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ChillThreshold"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.SpArithmetic.Percent)));
        }
        
        /// <summary>
        /// >> HistoryDepthParams
        ///  Number of eras to keep in history.
        /// 
        ///  Information is kept for eras in `[current_era - history_depth; current_era]`.
        /// 
        ///  Must be more than the number of eras delayed by session otherwise. I.e. active era must
        ///  always be in history. I.e. `active_era > current_era - history_depth` must be
        ///  guaranteed.
        /// </summary>
        public static string HistoryDepthParams()
        {
            return RequestGenerator.GetStorage("Staking", "HistoryDepth", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> HistoryDepth
        ///  Number of eras to keep in history.
        /// 
        ///  Information is kept for eras in `[current_era - history_depth; current_era]`.
        /// 
        ///  Must be more than the number of eras delayed by session otherwise. I.e. active era must
        ///  always be in history. I.e. `active_era > current_era - history_depth` must be
        ///  guaranteed.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> HistoryDepth(CancellationToken token)
        {
            string parameters = StakingStorage.HistoryDepthParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> ValidatorCountParams
        ///  The ideal number of staking participants.
        /// </summary>
        public static string ValidatorCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorCount", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of staking participants.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> ValidatorCount(CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorCountParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> MinimumValidatorCountParams
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public static string MinimumValidatorCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinimumValidatorCount", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinimumValidatorCount
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> MinimumValidatorCount(CancellationToken token)
        {
            string parameters = StakingStorage.MinimumValidatorCountParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> InvulnerablesParams
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public static string InvulnerablesParams()
        {
            return RequestGenerator.GetStorage("Staking", "Invulnerables", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public async Task<BaseVec<Ajuna.NetApi.Model.SpCore.AccountId32>> Invulnerables(CancellationToken token)
        {
            string parameters = StakingStorage.InvulnerablesParams();
            return await _client.GetStorageAsync<BaseVec<Ajuna.NetApi.Model.SpCore.AccountId32>>(parameters, token);
        }
        
        /// <summary>
        /// >> BondedParams
        ///  Map from all locked "stash" accounts to the controller account.
        /// </summary>
        public static string BondedParams(Ajuna.NetApi.Model.SpCore.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Bonded", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.SpCore.AccountId32> Bonded(Ajuna.NetApi.Model.SpCore.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.BondedParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.SpCore.AccountId32>(parameters, token);
        }
        
        /// <summary>
        /// >> MinNominatorBondParams
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public static string MinNominatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinNominatorBond", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> MinNominatorBond(CancellationToken token)
        {
            string parameters = StakingStorage.MinNominatorBondParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> MinValidatorBondParams
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public static string MinValidatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinValidatorBond", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> MinValidatorBond(CancellationToken token)
        {
            string parameters = StakingStorage.MinValidatorBondParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> LedgerParams
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// </summary>
        public static string LedgerParams(Ajuna.NetApi.Model.SpCore.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Ledger", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.StakingLedger> Ledger(Ajuna.NetApi.Model.SpCore.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.LedgerParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.StakingLedger>(parameters, token);
        }
        
        /// <summary>
        /// >> PayeeParams
        ///  Where the reward payment should be made. Keyed by stash.
        /// </summary>
        public static string PayeeParams(Ajuna.NetApi.Model.SpCore.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Payee", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination> Payee(Ajuna.NetApi.Model.SpCore.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.PayeeParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination>(parameters, token);
        }
        
        /// <summary>
        /// >> ValidatorsParams
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  When updating this storage item, you must also update the `CounterForValidators`.
        /// </summary>
        public static string ValidatorsParams(Ajuna.NetApi.Model.SpCore.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Validators", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  When updating this storage item, you must also update the `CounterForValidators`.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs> Validators(Ajuna.NetApi.Model.SpCore.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorsParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs>(parameters, token);
        }
        
        /// <summary>
        /// >> CounterForValidatorsParams
        ///  A tracker to keep count of the number of items in the `Validators` map.
        /// </summary>
        public static string CounterForValidatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForValidators", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForValidators
        ///  A tracker to keep count of the number of items in the `Validators` map.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> CounterForValidators(CancellationToken token)
        {
            string parameters = StakingStorage.CounterForValidatorsParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> MaxValidatorsCountParams
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxValidatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxValidatorsCount", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> MaxValidatorsCount(CancellationToken token)
        {
            string parameters = StakingStorage.MaxValidatorsCountParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> NominatorsParams
        ///  The map from nominator stash key to the set of stash keys of all validators to nominate.
        /// 
        ///  When updating this storage item, you must also update the `CounterForNominators`.
        /// </summary>
        public static string NominatorsParams(Ajuna.NetApi.Model.SpCore.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Nominators", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to the set of stash keys of all validators to nominate.
        /// 
        ///  When updating this storage item, you must also update the `CounterForNominators`.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.Nominations> Nominators(Ajuna.NetApi.Model.SpCore.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.NominatorsParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.Nominations>(parameters, token);
        }
        
        /// <summary>
        /// >> CounterForNominatorsParams
        ///  A tracker to keep count of the number of items in the `Nominators` map.
        /// </summary>
        public static string CounterForNominatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForNominators", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForNominators
        ///  A tracker to keep count of the number of items in the `Nominators` map.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> CounterForNominators(CancellationToken token)
        {
            string parameters = StakingStorage.CounterForNominatorsParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> MaxNominatorsCountParams
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxNominatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxNominatorsCount", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> MaxNominatorsCount(CancellationToken token)
        {
            string parameters = StakingStorage.MaxNominatorsCountParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> CurrentEraParams
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public static string CurrentEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "CurrentEra", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CurrentEra
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> CurrentEra(CancellationToken token)
        {
            string parameters = StakingStorage.CurrentEraParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> ActiveEraParams
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public static string ActiveEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ActiveEra", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.ActiveEraInfo> ActiveEra(CancellationToken token)
        {
            string parameters = StakingStorage.ActiveEraParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.ActiveEraInfo>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasStartSessionIndexParams
        ///  The session index at which the era start for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public static string ErasStartSessionIndexParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStartSessionIndex", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasStartSessionIndex
        ///  The session index at which the era start for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> ErasStartSessionIndex(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStartSessionIndexParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasStakersParams
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public static string ErasStakersParams(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakers", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasStakers
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.Exposure> ErasStakers(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.Exposure>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasStakersClippedParams
        ///  Clipped Exposure of validator at era.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxNominatorRewardedPerValidator` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public static string ErasStakersClippedParams(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakersClipped", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasStakersClipped
        ///  Clipped Exposure of validator at era.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxNominatorRewardedPerValidator` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.Exposure> ErasStakersClipped(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersClippedParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.Exposure>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasValidatorPrefsParams
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        /// </summary>
        public static string ErasValidatorPrefsParams(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorPrefs", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs> ErasValidatorPrefs(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasValidatorPrefsParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasValidatorRewardParams
        ///  The total validator era payout for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public static string ErasValidatorRewardParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorReward", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> ErasValidatorReward(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasValidatorRewardParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasRewardPointsParams
        ///  Rewards for the last `HISTORY_DEPTH` eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public static string ErasRewardPointsParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasRewardPoints", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last `HISTORY_DEPTH` eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.EraRewardPoints> ErasRewardPoints(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasRewardPointsParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.EraRewardPoints>(parameters, token);
        }
        
        /// <summary>
        /// >> ErasTotalStakeParams
        ///  The total amount staked for the last `HISTORY_DEPTH` eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public static string ErasTotalStakeParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasTotalStake", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last `HISTORY_DEPTH` eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> ErasTotalStake(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.ErasTotalStakeParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> ForceEraParams
        ///  Mode of era forcing.
        /// </summary>
        public static string ForceEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ForceEra", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.EnumForcing> ForceEra(CancellationToken token)
        {
            string parameters = StakingStorage.ForceEraParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.EnumForcing>(parameters, token);
        }
        
        /// <summary>
        /// >> SlashRewardFractionParams
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public static string SlashRewardFractionParams()
        {
            return RequestGenerator.GetStorage("Staking", "SlashRewardFraction", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.SpArithmetic.Perbill> SlashRewardFraction(CancellationToken token)
        {
            string parameters = StakingStorage.SlashRewardFractionParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.SpArithmetic.Perbill>(parameters, token);
        }
        
        /// <summary>
        /// >> CanceledSlashPayoutParams
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public static string CanceledSlashPayoutParams()
        {
            return RequestGenerator.GetStorage("Staking", "CanceledSlashPayout", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> CanceledSlashPayout(CancellationToken token)
        {
            string parameters = StakingStorage.CanceledSlashPayoutParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> UnappliedSlashesParams
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public static string UnappliedSlashesParams(Ajuna.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "UnappliedSlashes", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public async Task<BaseVec<Ajuna.NetApi.Model.PalletStaking.UnappliedSlash>> UnappliedSlashes(Ajuna.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = StakingStorage.UnappliedSlashesParams(key);
            return await _client.GetStorageAsync<BaseVec<Ajuna.NetApi.Model.PalletStaking.UnappliedSlash>>(parameters, token);
        }
        
        /// <summary>
        /// >> BondedErasParams
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public static string BondedErasParams()
        {
            return RequestGenerator.GetStorage("Staking", "BondedEras", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public async Task<BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.U32>>> BondedEras(CancellationToken token)
        {
            string parameters = StakingStorage.BondedErasParams();
            return await _client.GetStorageAsync<BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.U32>>>(parameters, token);
        }
        
        /// <summary>
        /// >> ValidatorSlashInEraParams
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public static string ValidatorSlashInEraParams(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorSlashInEra", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public async Task<BaseTuple<Ajuna.NetApi.Model.SpArithmetic.Perbill,Ajuna.NetApi.Model.Types.Primitive.U128>> ValidatorSlashInEra(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorSlashInEraParams(key);
            return await _client.GetStorageAsync<BaseTuple<Ajuna.NetApi.Model.SpArithmetic.Perbill,Ajuna.NetApi.Model.Types.Primitive.U128>>(parameters, token);
        }
        
        /// <summary>
        /// >> NominatorSlashInEraParams
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public static string NominatorSlashInEraParams(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "NominatorSlashInEra", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> NominatorSlashInEra
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U128> NominatorSlashInEra(BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.SpCore.AccountId32> key, CancellationToken token)
        {
            string parameters = StakingStorage.NominatorSlashInEraParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U128>(parameters, token);
        }
        
        /// <summary>
        /// >> SlashingSpansParams
        ///  Slashing spans for stash accounts.
        /// </summary>
        public static string SlashingSpansParams(Ajuna.NetApi.Model.SpCore.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "SlashingSpans", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SlashingSpans
        ///  Slashing spans for stash accounts.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.SlashingSpans> SlashingSpans(Ajuna.NetApi.Model.SpCore.AccountId32 key, CancellationToken token)
        {
            string parameters = StakingStorage.SlashingSpansParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.SlashingSpans>(parameters, token);
        }
        
        /// <summary>
        /// >> SpanSlashParams
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public static string SpanSlashParams(BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32,Ajuna.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("Staking", "SpanSlash", Ajuna.NetApi.Model.Meta.Storage.Type.Map, new Ajuna.NetApi.Model.Meta.Storage.Hasher[] {
                        Ajuna.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Ajuna.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SpanSlash
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.SpanRecord> SpanSlash(BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32,Ajuna.NetApi.Model.Types.Primitive.U32> key, CancellationToken token)
        {
            string parameters = StakingStorage.SpanSlashParams(key);
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.SpanRecord>(parameters, token);
        }
        
        /// <summary>
        /// >> EarliestUnappliedSlashParams
        ///  The earliest era for which we have a pending, unapplied slash.
        /// </summary>
        public static string EarliestUnappliedSlashParams()
        {
            return RequestGenerator.GetStorage("Staking", "EarliestUnappliedSlash", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> EarliestUnappliedSlash
        ///  The earliest era for which we have a pending, unapplied slash.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> EarliestUnappliedSlash(CancellationToken token)
        {
            string parameters = StakingStorage.EarliestUnappliedSlashParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> CurrentPlannedSessionParams
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public static string CurrentPlannedSessionParams()
        {
            return RequestGenerator.GetStorage("Staking", "CurrentPlannedSession", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CurrentPlannedSession
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> CurrentPlannedSession(CancellationToken token)
        {
            string parameters = StakingStorage.CurrentPlannedSessionParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> OffendingValidatorsParams
        ///  Indices of validators that have offended in the active era and whether they are currently
        ///  disabled.
        /// 
        ///  This value should be a superset of disabled validators since not all offences lead to the
        ///  validator being disabled (if there was no slash). This is needed to track the percentage of
        ///  validators that have offended in the current era, ensuring a new era is forced if
        ///  `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
        ///  whether a given validator has previously offended using binary search. It gets cleared when
        ///  the era ends.
        /// </summary>
        public static string OffendingValidatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "OffendingValidators", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> OffendingValidators
        ///  Indices of validators that have offended in the active era and whether they are currently
        ///  disabled.
        /// 
        ///  This value should be a superset of disabled validators since not all offences lead to the
        ///  validator being disabled (if there was no slash). This is needed to track the percentage of
        ///  validators that have offended in the current era, ensuring a new era is forced if
        ///  `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
        ///  whether a given validator has previously offended using binary search. It gets cleared when
        ///  the era ends.
        /// </summary>
        public async Task<BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.Bool>>> OffendingValidators(CancellationToken token)
        {
            string parameters = StakingStorage.OffendingValidatorsParams();
            return await _client.GetStorageAsync<BaseVec<BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32,Ajuna.NetApi.Model.Types.Primitive.Bool>>>(parameters, token);
        }
        
        /// <summary>
        /// >> StorageVersionParams
        ///  True if network has been upgraded to this version.
        ///  Storage version of the pallet.
        /// 
        ///  This is set to v7.0.0 for new networks.
        /// </summary>
        public static string StorageVersionParams()
        {
            return RequestGenerator.GetStorage("Staking", "StorageVersion", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> StorageVersion
        ///  True if network has been upgraded to this version.
        ///  Storage version of the pallet.
        /// 
        ///  This is set to v7.0.0 for new networks.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.PalletStaking.EnumReleases> StorageVersion(CancellationToken token)
        {
            string parameters = StakingStorage.StorageVersionParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.PalletStaking.EnumReleases>(parameters, token);
        }
        
        /// <summary>
        /// >> ChillThresholdParams
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public static string ChillThresholdParams()
        {
            return RequestGenerator.GetStorage("Staking", "ChillThreshold", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public async Task<Ajuna.NetApi.Model.SpArithmetic.Percent> ChillThreshold(CancellationToken token)
        {
            string parameters = StakingStorage.ChillThresholdParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.SpArithmetic.Percent>(parameters, token);
        }
    }
    
    public sealed class StakingCalls
    {
        
        /// <summary>
        /// >> bond
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Bond(Ajuna.NetApi.Model.SpRuntime.EnumMultiAddress controller, BaseCom<Ajuna.NetApi.Model.Types.Primitive.U128> value, Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination payee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controller.Encode());
            byteArray.AddRange(value.Encode());
            byteArray.AddRange(payee.Encode());
            return new Method(9, "Staking", 0, "bond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> bond_extra
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method BondExtra(BaseCom<Ajuna.NetApi.Model.Types.Primitive.U128> max_additional)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(max_additional.Encode());
            return new Method(9, "Staking", 1, "bond_extra", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> unbond
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Unbond(BaseCom<Ajuna.NetApi.Model.Types.Primitive.U128> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            return new Method(9, "Staking", 2, "unbond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> withdraw_unbonded
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method WithdrawUnbonded(Ajuna.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(9, "Staking", 3, "withdraw_unbonded", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> validate
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Validate(Ajuna.NetApi.Model.PalletStaking.ValidatorPrefs prefs)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(prefs.Encode());
            return new Method(9, "Staking", 4, "validate", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> nominate
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Nominate(BaseVec<Ajuna.NetApi.Model.SpRuntime.EnumMultiAddress> targets)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(targets.Encode());
            return new Method(9, "Staking", 5, "nominate", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> chill
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Chill()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(9, "Staking", 6, "chill", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_payee
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetPayee(Ajuna.NetApi.Model.PalletStaking.EnumRewardDestination payee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(payee.Encode());
            return new Method(9, "Staking", 7, "set_payee", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_controller
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetController(Ajuna.NetApi.Model.SpRuntime.EnumMultiAddress controller)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controller.Encode());
            return new Method(9, "Staking", 8, "set_controller", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_validator_count
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetValidatorCount(BaseCom<Ajuna.NetApi.Model.Types.Primitive.U32> @new)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(@new.Encode());
            return new Method(9, "Staking", 9, "set_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> increase_validator_count
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method IncreaseValidatorCount(BaseCom<Ajuna.NetApi.Model.Types.Primitive.U32> additional)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(additional.Encode());
            return new Method(9, "Staking", 10, "increase_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> scale_validator_count
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ScaleValidatorCount(Ajuna.NetApi.Model.SpArithmetic.Percent factor)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(factor.Encode());
            return new Method(9, "Staking", 11, "scale_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_no_eras
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceNoEras()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(9, "Staking", 12, "force_no_eras", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_new_era
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceNewEra()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(9, "Staking", 13, "force_new_era", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_invulnerables
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetInvulnerables(BaseVec<Ajuna.NetApi.Model.SpCore.AccountId32> invulnerables)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(invulnerables.Encode());
            return new Method(9, "Staking", 14, "set_invulnerables", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_unstake
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceUnstake(Ajuna.NetApi.Model.SpCore.AccountId32 stash, Ajuna.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(9, "Staking", 15, "force_unstake", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_new_era_always
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceNewEraAlways()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(9, "Staking", 16, "force_new_era_always", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> cancel_deferred_slash
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method CancelDeferredSlash(Ajuna.NetApi.Model.Types.Primitive.U32 era, BaseVec<Ajuna.NetApi.Model.Types.Primitive.U32> slash_indices)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(era.Encode());
            byteArray.AddRange(slash_indices.Encode());
            return new Method(9, "Staking", 17, "cancel_deferred_slash", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> payout_stakers
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method PayoutStakers(Ajuna.NetApi.Model.SpCore.AccountId32 validator_stash, Ajuna.NetApi.Model.Types.Primitive.U32 era)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(validator_stash.Encode());
            byteArray.AddRange(era.Encode());
            return new Method(9, "Staking", 18, "payout_stakers", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> rebond
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Rebond(BaseCom<Ajuna.NetApi.Model.Types.Primitive.U128> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            return new Method(9, "Staking", 19, "rebond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_history_depth
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetHistoryDepth(BaseCom<Ajuna.NetApi.Model.Types.Primitive.U32> new_history_depth, BaseCom<Ajuna.NetApi.Model.Types.Primitive.U32> era_items_deleted)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(new_history_depth.Encode());
            byteArray.AddRange(era_items_deleted.Encode());
            return new Method(9, "Staking", 20, "set_history_depth", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> reap_stash
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ReapStash(Ajuna.NetApi.Model.SpCore.AccountId32 stash, Ajuna.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(9, "Staking", 21, "reap_stash", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> kick
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Kick(BaseVec<Ajuna.NetApi.Model.SpRuntime.EnumMultiAddress> who)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(who.Encode());
            return new Method(9, "Staking", 22, "kick", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_staking_limits
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetStakingLimits(Ajuna.NetApi.Model.Types.Primitive.U128 min_nominator_bond, Ajuna.NetApi.Model.Types.Primitive.U128 min_validator_bond, BaseOpt<Ajuna.NetApi.Model.Types.Primitive.U32> max_nominator_count, BaseOpt<Ajuna.NetApi.Model.Types.Primitive.U32> max_validator_count, BaseOpt<Ajuna.NetApi.Model.SpArithmetic.Percent> threshold)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(min_nominator_bond.Encode());
            byteArray.AddRange(min_validator_bond.Encode());
            byteArray.AddRange(max_nominator_count.Encode());
            byteArray.AddRange(max_validator_count.Encode());
            byteArray.AddRange(threshold.Encode());
            return new Method(9, "Staking", 23, "set_staking_limits", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> chill_other
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ChillOther(Ajuna.NetApi.Model.SpCore.AccountId32 controller)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controller.Encode());
            return new Method(9, "Staking", 24, "chill_other", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> EraPaid
    /// The era payout has been set; the first balance is the validator-payout; the second is
    /// the remainder from the maximum amount of reward.
    /// \[era_index, validator_payout, remainder\]
    /// </summary>
    public sealed class EventEraPaid : BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, Ajuna.NetApi.Model.Types.Primitive.U128, Ajuna.NetApi.Model.Types.Primitive.U128>
    {
    }
    
    /// <summary>
    /// >> Rewarded
    /// The nominator has been rewarded by this amount. \[stash, amount\]
    /// </summary>
    public sealed class EventRewarded : BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32, Ajuna.NetApi.Model.Types.Primitive.U128>
    {
    }
    
    /// <summary>
    /// >> Slashed
    /// One validator (and its nominators) has been slashed by the given amount.
    /// \[validator, amount\]
    /// </summary>
    public sealed class EventSlashed : BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32, Ajuna.NetApi.Model.Types.Primitive.U128>
    {
    }
    
    /// <summary>
    /// >> OldSlashingReportDiscarded
    /// An old slashing report from a prior era was discarded because it could
    /// not be processed. \[session_index\]
    /// </summary>
    public sealed class EventOldSlashingReportDiscarded : BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32>
    {
    }
    
    /// <summary>
    /// >> StakersElected
    /// A new set of stakers was elected.
    /// </summary>
    public sealed class EventStakersElected : BaseTuple
    {
    }
    
    /// <summary>
    /// >> Bonded
    /// An account has bonded this amount. \[stash, amount\]
    /// 
    /// NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
    /// it will not be emitted for staking rewards when they are added to stake.
    /// </summary>
    public sealed class EventBonded : BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32, Ajuna.NetApi.Model.Types.Primitive.U128>
    {
    }
    
    /// <summary>
    /// >> Unbonded
    /// An account has unbonded this amount. \[stash, amount\]
    /// </summary>
    public sealed class EventUnbonded : BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32, Ajuna.NetApi.Model.Types.Primitive.U128>
    {
    }
    
    /// <summary>
    /// >> Withdrawn
    /// An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
    /// from the unlocking queue. \[stash, amount\]
    /// </summary>
    public sealed class EventWithdrawn : BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32, Ajuna.NetApi.Model.Types.Primitive.U128>
    {
    }
    
    /// <summary>
    /// >> Kicked
    /// A nominator has been kicked from a validator. \[nominator, stash\]
    /// </summary>
    public sealed class EventKicked : BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32, Ajuna.NetApi.Model.SpCore.AccountId32>
    {
    }
    
    /// <summary>
    /// >> StakingElectionFailed
    /// The election failed. No new era is planned.
    /// </summary>
    public sealed class EventStakingElectionFailed : BaseTuple
    {
    }
    
    /// <summary>
    /// >> Chilled
    /// An account has stopped participating as either a validator or nominator.
    /// \[stash\]
    /// </summary>
    public sealed class EventChilled : BaseTuple<Ajuna.NetApi.Model.SpCore.AccountId32>
    {
    }
    
    /// <summary>
    /// >> PayoutStarted
    /// The stakers' rewards are getting paid. \[era_index, validator_stash\]
    /// </summary>
    public sealed class EventPayoutStarted : BaseTuple<Ajuna.NetApi.Model.Types.Primitive.U32, Ajuna.NetApi.Model.SpCore.AccountId32>
    {
    }
    
    public enum StakingErrors
    {
        
        /// <summary>
        /// >> NotController
        /// Not a controller account.
        /// </summary>
        NotController,
        
        /// <summary>
        /// >> NotStash
        /// Not a stash account.
        /// </summary>
        NotStash,
        
        /// <summary>
        /// >> AlreadyBonded
        /// Stash is already bonded.
        /// </summary>
        AlreadyBonded,
        
        /// <summary>
        /// >> AlreadyPaired
        /// Controller is already paired.
        /// </summary>
        AlreadyPaired,
        
        /// <summary>
        /// >> EmptyTargets
        /// Targets cannot be empty.
        /// </summary>
        EmptyTargets,
        
        /// <summary>
        /// >> DuplicateIndex
        /// Duplicate index.
        /// </summary>
        DuplicateIndex,
        
        /// <summary>
        /// >> InvalidSlashIndex
        /// Slash record index out of bounds.
        /// </summary>
        InvalidSlashIndex,
        
        /// <summary>
        /// >> InsufficientBond
        /// Can not bond with value less than minimum required.
        /// </summary>
        InsufficientBond,
        
        /// <summary>
        /// >> NoMoreChunks
        /// Can not schedule more unlock chunks.
        /// </summary>
        NoMoreChunks,
        
        /// <summary>
        /// >> NoUnlockChunk
        /// Can not rebond without unlocking chunks.
        /// </summary>
        NoUnlockChunk,
        
        /// <summary>
        /// >> FundedTarget
        /// Attempting to target a stash that still has funds.
        /// </summary>
        FundedTarget,
        
        /// <summary>
        /// >> InvalidEraToReward
        /// Invalid era to reward.
        /// </summary>
        InvalidEraToReward,
        
        /// <summary>
        /// >> InvalidNumberOfNominations
        /// Invalid number of nominations.
        /// </summary>
        InvalidNumberOfNominations,
        
        /// <summary>
        /// >> NotSortedAndUnique
        /// Items are not sorted and unique.
        /// </summary>
        NotSortedAndUnique,
        
        /// <summary>
        /// >> AlreadyClaimed
        /// Rewards for this era have already been claimed for this validator.
        /// </summary>
        AlreadyClaimed,
        
        /// <summary>
        /// >> IncorrectHistoryDepth
        /// Incorrect previous history depth input provided.
        /// </summary>
        IncorrectHistoryDepth,
        
        /// <summary>
        /// >> IncorrectSlashingSpans
        /// Incorrect number of slashing spans provided.
        /// </summary>
        IncorrectSlashingSpans,
        
        /// <summary>
        /// >> BadState
        /// Internal state has become somehow corrupted and the operation cannot continue.
        /// </summary>
        BadState,
        
        /// <summary>
        /// >> TooManyTargets
        /// Too many nomination targets supplied.
        /// </summary>
        TooManyTargets,
        
        /// <summary>
        /// >> BadTarget
        /// A nomination target was supplied that was blocked or otherwise not a validator.
        /// </summary>
        BadTarget,
        
        /// <summary>
        /// >> CannotChillOther
        /// The user has enough bond and thus cannot be chilled forcefully by an external person.
        /// </summary>
        CannotChillOther,
        
        /// <summary>
        /// >> TooManyNominators
        /// There are too many nominators in the system. Governance needs to adjust the staking
        /// settings to keep things safe for the runtime.
        /// </summary>
        TooManyNominators,
        
        /// <summary>
        /// >> TooManyValidators
        /// There are too many validators in the system. Governance needs to adjust the staking
        /// settings to keep things safe for the runtime.
        /// </summary>
        TooManyValidators,
    }
}

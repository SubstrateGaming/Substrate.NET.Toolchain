//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Ajuna.Infrastructure.Storages;
using Ajuna.NetApi.Model.Base;
using Ajuna.NetApi.Model.FrameSupport;
using Ajuna.NetApi.Model.PalletElectionProviderMultiPhase;
using Ajuna.NetApi.Model.Types.Base;
using Ajuna.NetApi.Model.Types.Primitive;
using Microsoft.AspNetCore.Mvc;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;


namespace Ajuna.Infrastructure.RestService.Controller
{
    
    
    /// <summary>
    /// ElectionProviderMultiPhaseController controller to access storages.
    /// </summary>
    [ApiController()]
    [Route("[controller]")]
    public sealed class ElectionProviderMultiPhaseController : ControllerBase
    {
        
        private IElectionProviderMultiPhaseStorage _electionProviderMultiPhaseStorage;
        
        /// <summary>
        /// ElectionProviderMultiPhaseController constructor.
        /// </summary>
        public ElectionProviderMultiPhaseController(IElectionProviderMultiPhaseStorage electionProviderMultiPhaseStorage)
        {
            _electionProviderMultiPhaseStorage = electionProviderMultiPhaseStorage;
        }
        
        /// <summary>
        /// >> Round
        ///  Internal counter for the number of rounds.
        /// 
        ///  This is useful for de-duplication of transactions submitted to the pool, and general
        ///  diagnostics of the pallet.
        /// 
        ///  This is merely incremented once per every time that an upstream `elect` is called.
        /// </summary>
        [HttpGet("Round")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.Types.Primitive.U32), 200)]
        public IActionResult GetRound()
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetRound());
        }
        
        /// <summary>
        /// >> CurrentPhase
        ///  Current phase.
        /// </summary>
        [HttpGet("CurrentPhase")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.EnumPhase), 200)]
        public IActionResult GetCurrentPhase()
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetCurrentPhase());
        }
        
        /// <summary>
        /// >> QueuedSolution
        ///  Current best solution, signed or unsigned, queued to be returned upon `elect`.
        /// </summary>
        [HttpGet("QueuedSolution")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.ReadySolution), 200)]
        public IActionResult GetQueuedSolution()
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetQueuedSolution());
        }
        
        /// <summary>
        /// >> Snapshot
        ///  Snapshot data of the round.
        /// 
        ///  This is created at the beginning of the signed phase and cleared upon calling `elect`.
        /// </summary>
        [HttpGet("Snapshot")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.RoundSnapshot), 200)]
        public IActionResult GetSnapshot()
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetSnapshot());
        }
        
        /// <summary>
        /// >> DesiredTargets
        ///  Desired number of targets to elect for this round.
        /// 
        ///  Only exists when [`Snapshot`] is present.
        /// </summary>
        [HttpGet("DesiredTargets")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.Types.Primitive.U32), 200)]
        public IActionResult GetDesiredTargets()
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetDesiredTargets());
        }
        
        /// <summary>
        /// >> SnapshotMetadata
        ///  The metadata of the [`RoundSnapshot`]
        /// 
        ///  Only exists when [`Snapshot`] is present.
        /// </summary>
        [HttpGet("SnapshotMetadata")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SolutionOrSnapshotSize), 200)]
        public IActionResult GetSnapshotMetadata()
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetSnapshotMetadata());
        }
        
        /// <summary>
        /// >> SignedSubmissionNextIndex
        ///  The next index to be assigned to an incoming signed submission.
        /// 
        ///  Every accepted submission is assigned a unique index; that index is bound to that particular
        ///  submission for the duration of the election. On election finalization, the next index is
        ///  reset to 0.
        /// 
        ///  We can&#39;t just use `SignedSubmissionIndices.len()`, because that&#39;s a bounded set; past its
        ///  capacity, it will simply saturate. We can&#39;t just iterate over `SignedSubmissionsMap`,
        ///  because iteration is slow. Instead, we store the value here.
        /// </summary>
        [HttpGet("SignedSubmissionNextIndex")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.Types.Primitive.U32), 200)]
        public IActionResult GetSignedSubmissionNextIndex()
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetSignedSubmissionNextIndex());
        }
        
        /// <summary>
        /// >> SignedSubmissionIndices
        ///  A sorted, bounded set of `(score, index)`, where each `index` points to a value in
        ///  `SignedSubmissions`.
        /// 
        ///  We never need to process more than a single signed submission at a time. Signed submissions
        ///  can be quite large, so we&#39;re willing to pay the cost of multiple database accesses to access
        ///  them one at a time instead of reading and decoding all of them at once.
        /// </summary>
        [HttpGet("SignedSubmissionIndices")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.FrameSupport.BoundedBTreeMap), 200)]
        public IActionResult GetSignedSubmissionIndices()
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetSignedSubmissionIndices());
        }
        
        /// <summary>
        /// >> SignedSubmissionsMap
        ///  Unchecked, signed solutions.
        /// 
        ///  Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
        ///  allowing us to keep only a single one in memory at a time.
        /// 
        ///  Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
        ///  affect; we shouldn&#39;t need a cryptographically secure hasher.
        /// </summary>
        [HttpGet("SignedSubmissionsMap")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.PalletElectionProviderMultiPhase.SignedSubmission), 200)]
        public IActionResult GetSignedSubmissionsMap(string key)
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetSignedSubmissionsMap(key));
        }
        
        /// <summary>
        /// >> MinimumUntrustedScore
        ///  The minimum score that each &#39;untrusted&#39; solution must attain in order to be considered
        ///  feasible.
        /// 
        ///  Can be set via `set_minimum_untrusted_score`.
        /// </summary>
        [HttpGet("MinimumUntrustedScore")]
        [ProducesResponseType(typeof(Ajuna.NetApi.Model.Base.Arr3U128), 200)]
        public IActionResult GetMinimumUntrustedScore()
        {
            return this.Ok(_electionProviderMultiPhaseStorage.GetMinimumUntrustedScore());
        }
    }
}

using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Substrate.NetApi.Model.Meta;
using System;
using Serilog;
using System.Net.NetworkInformation;

namespace Substrate.DotNet.Service.Node.Base
{
   public abstract class BuilderBaseRoslyn
   {
      protected static readonly List<string> Files = new();

      public uint Id { get; }

      protected NodeTypeResolver Resolver { get; }

      public bool Success { get; set; }

      public string NamespaceName { get; protected set; }

      internal string FileName { get; set; }

      public string ClassName { get; set; }

      public string ReferenzName { get; set; }

      public string ProjectName { get; private set; }

      public CompilationUnitSyntax TargetUnit { get; set; }

      public abstract BuilderBaseRoslyn Create();

      protected BuilderBaseRoslyn(string projectName, uint id, NodeTypeResolver resolver)
      {
         ProjectName = projectName;
         Id = id;
         Resolver = resolver;
         TargetUnit = SyntaxFactory.CompilationUnit()
            .AddUsings(
                SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("Substrate.NetApi.Model.Types.Base")),
                SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Collections.Generic")));
         Success = true;
      }

      public static string EscapeIfKeyword(string parameterName)
      {
         if (SyntaxFacts.GetKeywordKind(parameterName) != SyntaxKind.None)
         {
            // If it is a keyword, create a verbatim identifier which adds '@' prefix
            parameterName = "@" + parameterName;
         }

         return parameterName;
      }

      public NodeTypeResolved GetFullItemPath(uint typeId)
      {
         if (!Resolver.TypeNames.TryGetValue(typeId, out NodeTypeResolved fullItem))
         {
            Success = false;
            return null;
         }

         return fullItem;
      }

      public virtual void Build(bool write, out bool success, string basePath = null)
      {
         success = Success;
         if (write && Success)
         {
            string path = GetPath(basePath);

            Directory.CreateDirectory(Path.GetDirectoryName(path));

            if (!Files.Contains(path))
            {
               Files.Add(path);
            }
            else
            {
               Log.Warning($"Overwriting[BUG]: {path}");
            }

            // add autogenerated header
            TargetUnit = TargetUnit.WithLeadingTrivia(SyntaxFactory.TriviaList(HeaderComment));

            using StreamWriter sourceWriter = new(path);
            sourceWriter.Write(TargetUnit.NormalizeWhitespace().ToFullString());
         }
      }

      private string GetPath(string basePath)
      {
         var space = NamespaceName.Split('.').ToList();

         space.Add((FileName is null ? ClassName : FileName) + ".cs");

         // Remove the first two parts of the namespace to avoid the files being created in the Substrate/NetApi sub folder.
         space = space.TakeLast(space.Count - 2).ToList();

         // Add base path at the beginning of the paths list
         if (!string.IsNullOrEmpty(basePath))
         {
            space.Insert(0, basePath);
         }

         string path = Path.Combine(space.ToArray());

         return path;
      }

      protected ClassDeclarationSyntax AddTargetClassCustomAttributesRoslyn(ClassDeclarationSyntax targetClass, NodeType typeDef)
      {
         // TODO (svnscha): Change version to given metadata version.
         TargetUnit = TargetUnit.AddUsings(
                SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("Substrate.NetApi.Model.Types.Metadata.V14")),
                SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("Substrate.NetApi.Attributes")));

         AttributeArgumentSyntax attributeArgument = SyntaxFactory.AttributeArgument(
             SyntaxFactory.ParseExpression($"TypeDefEnum.{typeDef.TypeDef}"));

         AttributeListSyntax attributeList = SyntaxFactory.AttributeList(
             SyntaxFactory.SingletonSeparatedList(
                 SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("SubstrateNodeType"), SyntaxFactory.AttributeArgumentList(SyntaxFactory.SingletonSeparatedList(attributeArgument)))));

         return targetClass.AddAttributeLists(attributeList);
      }

      public static MethodDeclarationSyntax SimpleMethodRoslyn(string name, string returnType = null, object returnExpression = null)
      {
         MethodDeclarationSyntax nameMethod = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName(returnType ?? "void"), name)
             .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.OverrideKeyword));

         if (returnType != null && returnExpression != null)
         {
            nameMethod = nameMethod.WithBody(SyntaxFactory.Block(
                SyntaxFactory.ReturnStatement(SyntaxFactory.ParseExpression($"\"{returnExpression}\""))
            ));
         }

         return nameMethod;
      }

      public static SyntaxTriviaList GetCommentsRoslyn(string[] docs, NodeType typeDef = null, string typeName = null)
      {
         var commentList = new List<SyntaxTrivia>
         {
            SyntaxFactory.Comment("/// <summary>")
         };

         if (typeDef != null)
         {
            string path = typeDef.Path != null ? "[" + string.Join('.', typeDef.Path) + "]" : "";
            commentList.Add(SyntaxFactory.Comment($"/// >> {typeDef.Id} - {typeDef.TypeDef}{path}"));
         }

         if (typeName != null)
         {
            commentList.Add(SyntaxFactory.Comment($"/// >> {typeName}"));
         }

         if (docs != null)
         {
            foreach (string doc in docs)
            {
               string[] lines = doc.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);

               foreach (string line in lines)
               {
                  commentList.Add(SyntaxFactory.Comment($"/// {line}"));
               }
            }
         }

         commentList.Add(SyntaxFactory.Comment("/// </summary>"));

         return SyntaxFactory.TriviaList(commentList);
      }

      public static SyntaxTrivia HeaderComment => SyntaxFactory.Comment(
@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------");

   }
}